package main

import (
	"encoding/binary"
	"encoding/hex"
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"time"
	// "github.com/zate/gogasm/rcon"
)


// CheckNoError standard error checking function
func CheckNoError(err error) bool {
	if err != nil {
		log.Println("Error: ", err)
		return false
	}
	return true
}

// Colorize wraps color around a string
func Colorize(s string) string {
	return "\033[1;31m" + s + "\033[0m"
}

// MyHexDump takes in array of bytes and and inter and returns a string
func MyHexDump(arr []byte, s int) string {
	var b = make([]byte, s)
	for i := 0; i < s; i++ {
		b[i] = arr[i]
	}
	if colorize {
		return Colorize(hex.Dump(b))
	}
	return hex.Dump(b)
}

// SendPacket sends a packet,duh.
func SendPacket(conn net.Conn, arr []byte, timeout time.Duration) (int, []byte) {
	if debug {
		fmt.Fprintln(os.Stderr, "Writing...")
	}
	ret, err := conn.Write(arr)
	if debug {
		fmt.Fprintf(os.Stderr, MyHexDump(arr, ret))
	}
	if CheckNoError(err) {
		if debug {
			fmt.Fprintf(os.Stderr, "Wrote %d bytes\n", ret)
		}
		buffer := make([]byte, 1500)
		if debug {
			fmt.Fprintln(os.Stderr, "Reading...")
		}
		conn.SetReadDeadline(time.Now().Add(timeout))
		n, err := conn.Read(buffer)
		if CheckNoError(err) {
			if debug {
				fmt.Fprintf(os.Stderr, "Read %d bytes\n", n)
			}
			if debug {
				fmt.Fprintf(os.Stderr, MyHexDump(buffer, n))
			}
			return n, buffer
		}
		return 0, nil
	}
	return 0, nil
}

func stripCtlAndExtFromBytes(str string) string {
	b := make([]byte, len(str))
	var bl int
	for i := 0; i < len(str); i++ {
		c := str[i]
		if c >= 32 && c < 127 {
			b[bl] = c
			bl++
		}
	}
	return string(b[:bl])
}

// GetString used to pull strings from array of bytes returned from SendPacket
func GetString(arr []byte, index int) (string, int) {
	data := ""
	for i := index; i < len(arr); i++ {
		index = i
		if arr[i] == 0x00 {
			break
		} else {
			data = data + string(arr[i])
		}
	}
	index++
	data = stripCtlAndExtFromBytes(data)
	return data, index
}

// GetUInt16 converts array of bytes to uint16
func GetUInt16(arr []byte, index int) (uint16, int) {
	num1 := arr[index]
	index++
	num2 := arr[index]
	index++
	num := uint16(num1) | uint16(num2)<<8
	return num, index
}

// GetUInt32 converts array of bytes to uint32
func GetUInt32(arr []byte, index int) (uint32, int) {
	num1 := arr[index]
	index++
	num2 := arr[index]
	index++
	num3 := arr[index]
	index++
	num4 := arr[index]
	index++
	num := uint32(num4)<<24 | uint32(num3)<<16 | uint32(num2)<<8 | uint32(num1)
	return num, index
}

// CheckHeader to see if it's the right byte fotmat
func CheckHeader(hdr byte, chk byte) bool {
	if hdr != chk {
		log.Printf("Header was 0x%x instead of 0x%x\n", hdr, chk)
		return false
	}
	return true
}

// ServerPing sends a Query Protocol Ping packet to the server and looks at
// response
func ServerPing(cfg Config) {
	a2sPing := []byte{0xFF, 0xFF, 0xFF, 0xFF, 0x56, 0xFF, 0xFF, 0xFF, 0xFF}
	server := cfg.AtlasIP
	port := cfg.AtlasQueryPort
	timeout := 1500 * time.Millisecond
	sp := server + ":" + port

	//log.Printf("Pinging : %s", sp)

	conn, err := net.DialTimeout("udp", sp, timeout)
	if err != nil {
		return
	}

	defer conn.Close()

	ret, err := conn.Write(a2sPing)
	if ret == 0 || err != nil {
		//log.Printf("%s is dead\n", sp)
		return
	}
	BytesReceived := make([]byte, 1500)
	conn.SetReadDeadline(time.Now().Add(timeout))
	n, err := conn.Read(BytesReceived)

	if BytesReceived == nil || n == 0 {
		//log.Printf("%s is dead\n", sp)
		return
	}

	if !CheckHeader(BytesReceived[4], 0x41) {
		//log.Printf("%s is dead\n", sp)
		return
	}

	//log.Printf("%s is alive\n", sp)
	CheckStatus(cfg)
}

// CheckStatus sends a Server Query Protocol request and prses the response
func CheckStatus(cfg Config) {
	sinfo := Info{}
	a2sInfo := []byte{0xFF, 0xFF, 0xFF, 0xFF, 0x54, 0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x45, 0x6E, 0x67, 0x69, 0x6E, 0x65, 0x20, 0x51, 0x75, 0x65, 0x72, 0x79, 0x00}

	a2sRules := []byte{0xFF, 0xFF, 0xFF, 0xFF, 0x56, 0xFF, 0xFF, 0xFF, 0xFF}
	//a2sPlayer := []byte{0xFF, 0xFF, 0xFF, 0xFF, 0x55, 0xFF, 0xFF, 0xFF, 0xFF}
	server := cfg.AtlasIP
	port := cfg.AtlasQueryPort
	seconds := 3
	timeout := time.Duration(seconds) * time.Second
	sp := server + ":" + port
	//log.Printf("Debug: %s\n", strings.TrimSpace(sp))
	if debug {
		fmt.Fprintln(os.Stderr, "Opening UDP connection...")
	}
	Conn, err := net.DialTimeout("udp", sp, timeout)
	if err != nil {
		return
	}

	defer Conn.Close()

	// Get Info

	if debug {
		fmt.Fprintln(os.Stderr, "Sending A2S_INFO...")
	}

	start := time.Now()
	n, BytesReceived := SendPacket(Conn, a2sInfo, timeout)
	t := time.Now()
	elapsed1 := t.Sub(start)

	if BytesReceived == nil || n == 0 {
		log.Println("Received no data!")
		return
	}

	if !CheckHeader(BytesReceived[4], 0x49) {
		return
	}

	if debug {
		fmt.Fprintf(os.Stderr, "HEADER: 0x%x\n", BytesReceived[4])
	}
	if debug {
		fmt.Fprintf(os.Stderr, "PROTOCOL: 0x%x\n", BytesReceived[5])
	}

	var sPtr int
	var info string
	sPtr = 5
	sinfo.Name, sPtr = GetString(BytesReceived, sPtr)
	// fmt.Printf("NAME: %s\n", sinfo.Name)

	sinfo.Map, sPtr = GetString(BytesReceived, sPtr)
	// fmt.Printf("MAP: %s\n", sinfo.Map)

	sinfo.Folder, sPtr = GetString(BytesReceived, sPtr)
	// fmt.Printf("FOLDER: %s\n", sinfo.Folder)

	sinfo.Game, sPtr = GetString(BytesReceived, sPtr)
	// fmt.Printf("GAME: %s\n", info)

	//var id uint16
	sinfo.ID, sPtr = GetUInt16(BytesReceived, sPtr)
	//fmt.Printf("ID: %d\n", id)

	sinfo.Players = BytesReceived[sPtr]
	//fmt.Printf("PLAYERS: %d\n", BytesReceived[sPtr])
	sPtr++

	sinfo.MaxPlayers = BytesReceived[sPtr]
	//fmt.Printf("MAXPLAYERS: %d\n", BytesReceived[sPtr])
	sPtr++

	sinfo.Bot = BytesReceived[sPtr]
	//fmt.Printf("BOTS: %d\n", BytesReceived[sPtr])
	sPtr++

	sinfo.ServerType = BytesReceived[sPtr]
	//fmt.Printf("SERVERTYPE: %c\n", BytesReceived[sPtr])
	sPtr++

	sinfo.Environment = BytesReceived[sPtr]
	//fmt.Printf("ENVIRONMENT: %c\n", BytesReceived[sPtr])
	sPtr++

	sinfo.Visibility = BytesReceived[sPtr]
	//fmt.Printf("VISIBILITY: %d\n", BytesReceived[sPtr])
	sPtr++

	sinfo.Vac = BytesReceived[sPtr]
	//fmt.Printf("VAC: %d\n", BytesReceived[sPtr])
	sPtr++

	sinfo.Version, sPtr = GetString(BytesReceived, sPtr)
	//fmt.Printf("VERSION: %s\n", info)

	if n > sPtr {
		// EDF
		edf := BytesReceived[sPtr]
		sPtr++

		// PORT
		if edf&0x80 != 0 {
			//var port uint16
			sinfo.Port, _ = GetUInt16(BytesReceived, sPtr)
			//fmt.Printf("PORT: %d\n", port)
		}

		// STEAMID
		if edf&0x10 != 0 {
			sPtr += 8
		}

		// Keywords
		if edf&0x20 != 0 {
			sinfo.KeyWords, sPtr = GetString(BytesReceived, sPtr)
			//fmt.Printf("KEYWORDS: %s\n", info)
		}
	}

	// Get Rules
	sPtr = 5

	if debug {
		log.Println("Sending A2S_RULES...")
	}

	start = time.Now()
	n, BytesReceived = SendPacket(Conn, a2sRules, timeout)
	t = time.Now()
	elapsed2 := t.Sub(start)

	if BytesReceived == nil || n == 0 {
		log.Printf("Received no data! for %s A2S_RULES", sp)
		return
	}

	if !CheckHeader(BytesReceived[4], 0x41) {
		return
	}

	// Challenge number
	var chnum uint32
	chnum, sPtr = GetUInt32(BytesReceived, sPtr)
	if debug {
		log.Printf("Challenge number: %d\n", chnum)
	}

	a2sRules[5] = byte(chnum)
	a2sRules[6] = byte(chnum >> 8)
	a2sRules[7] = byte(chnum >> 16)
	a2sRules[8] = byte(chnum >> 24)

	if debug {
		log.Println("Sending A2S_RULES...")
	}

	start = time.Now()
	n, BytesReceived = SendPacket(Conn, a2sRules, timeout)
	t = time.Now()
	elapsed3 := t.Sub(start)

	if BytesReceived == nil || n == 0 {
		log.Println("Received no data!")
		return
	}

	elapsed := (elapsed1 + elapsed2 + elapsed3) / 3
	sinfo.Ping = int(elapsed) / 1000000
	//fmt.Printf("PING: %d\n", int(elapsed)/1000000)

	if !CheckHeader(BytesReceived[4], 0x45) {
		return
	}

	// reset sPtr
	sPtr = 5
	var rules uint16
	rules, sPtr = GetUInt16(BytesReceived, sPtr)
	rulesMap := make(map[string]string)
	if rules > 0 {
		//fmt.Println("RULE LIST:")
	}

	for i := uint16(0); i < rules; i++ {
		// Name
		info, sPtr = GetString(BytesReceived, sPtr)
		// Value
		val := ""
		val, sPtr = GetString(BytesReceived, sPtr)
		rulesMap[info] = val
		//fmt.Printf("%s %s\n", info, val)
	}
	// ATLASFRIENDLYNAME_s
	// PLAYERS: 26
	// PING: 96
	// CUSTOMSERVERNAME_s
	// ISHOMESERVER_b
	// SESSIONFLAGS string
	// SESSIONISPVE_i 1
	//if rulesMap["CUSTOMSERVERNAME_s"] == "golden age ruins" {
	log.Printf("%s : %s | %s | %d | %d \n", sp, rulesMap["ATLASFRIENDLYNAME_s"], rulesMap["CUSTOMSERVERNAME_s"], sinfo.Players, sinfo.Ping)
	//}
	// log.Printf("%s | %s | %d | %d | %s | %s | %s\n", rulesMap["ATLASFRIENDLYNAME_s"], rulesMap["CUSTOMSERVERNAME_s"], sinfo.Players, sinfo.Ping, rulesMap["ISHOMESERVER_b"], rulesMap["SESSIONFLAGS"], rulesMap["SESSIONISPVE_i"])

	// // Get Players
	// sPtr = 5

	// if debug {
	// 	fmt.Fprintln(os.Stderr, "Sending A2S_PLAYER...")
	// }
	// n, BytesReceived = SendPacket(Conn, a2sPlayer, timeout)

	// if BytesReceived == nil || n == 0 {
	// 	fmt.Fprintln(os.Stderr, "Received no data!")
	// 	os.Exit(2)
	// }

	// if !CheckHeader(BytesReceived[4], 0x41) {
	// 	os.Exit(2)
	// }

	// // Challenge number
	// chnum, sPtr = GetUInt32(BytesReceived, sPtr)
	// if debug {
	// 	fmt.Fprintf(os.Stderr, "Challenge number: %d\n", chnum)
	// }

	// a2sPlayer[5] = byte(chnum)
	// a2sPlayer[6] = byte(chnum >> 8)
	// a2sPlayer[7] = byte(chnum >> 16)
	// a2sPlayer[8] = byte(chnum >> 24)

	// if debug {
	// 	fmt.Fprintln(os.Stderr, "Sending A2S_PLAYER...")
	// }
	// n, BytesReceived = SendPacket(Conn, a2sPlayer, timeout)

	// if BytesReceived == nil || n == 0 {
	// 	fmt.Fprintln(os.Stderr, "Received no data!")
	// 	os.Exit(2)
	// }

	// if !CheckHeader(BytesReceived[4], 0x44) {
	// 	os.Exit(2)
	// }

	// sPtr = 5
	// players := BytesReceived[sPtr]
	// sPtr++

	// if players > 0 {
	// 	fmt.Println("PLAYER LIST:")
	// }

	// var score uint32

	// for i := 0; i < int(players); i++ {
	// 	// Index (this seems to always be 0, so skipping it)
	// 	sPtr++

	// 	// Name
	// 	info, sPtr = GetString(BytesReceived, sPtr)

	// 	// Score
	// 	score, sPtr = GetUInt32(BytesReceived, sPtr)

	// 	// Duration
	// 	b := []byte{0x00, 0x00, 0x00, 0x00}
	// 	b[0] = BytesReceived[sPtr]
	// 	sPtr++
	// 	b[1] = BytesReceived[sPtr]
	// 	sPtr++
	// 	b[2] = BytesReceived[sPtr]
	// 	sPtr++
	// 	b[3] = BytesReceived[sPtr]
	// 	sPtr++
	// 	var duration float32
	// 	buf := bytes.NewReader(b)
	// 	err := binary.Read(buf, binary.LittleEndian, &duration)
	// 	if err != nil {
	// 		fmt.Fprintln(os.Stderr, "Float conversion failed:", err)
	// 	}

	// 	fmt.Printf("%s %d %.0f\n", info, score, duration)
	// }
	// r, err := rcon.Dial(server+":27025", "changeme")
	// r.Write()
	return
}

func toGrid(s, gs int) (grid string) {
	g := (s % gs) + 1
	l := (s / gs)
	letter := string('A' + l)
	//log.Printf("count: %v is %v%v", count, letter, g)
	grid = letter + strconv.Itoa(g)
	return grid
}

// Grid attempts to map official server space for each port/ip combo
func makeGrid(gridSize, portsPerServer int) {
	//var coord string

	count := 0

	portCount := 1

	for i := 0; i < (gridSize*gridSize)+1; i++ {

		// g := (count % gridSize) + 1
		// l := (count / gridSize) + 1
		// letter = string('A' - 1 + l)
		ipcount := (count / portsPerServer)
		portNum := 57554 + portCount

		log.Printf("count: %v is %v and ip: %v port: %v", count, toGrid(count, gridSize), ipcount, portNum)

		portCount++
		portCount++
		if portCount == 9 {
			portCount = 1
		}
		count++
	}
	return

}

// AddOfficialRealm takes a []Realm struct and adds it to the base AtlasServers
// struct
func (l *AtlasServers) AddOfficialRealm(realm Realm) []Realm {
	l.Official = append(l.Official, realm)
	return l.Official
}

// AddGrid takes a []Grids struct and adds it to the Realm struct
func (r *Realm) AddGrid(grid Grids) []Grids {
	r.Grids = append(r.Grids, grid)
	return r.Grids
}

// incIP increments the base IP by int and returns a string
func incIP(ip string, i int) string {
	ui := uint32(i)
	s := int2ip(ip2int(net.ParseIP(ip)) + ui)

	//log.Println(s.String())
	return s.String()
}

func ip2int(ip net.IP) uint32 {
	if len(ip) == 16 {
		return binary.BigEndian.Uint32(ip[12:16])
	}
	return binary.BigEndian.Uint32(ip)
}

func int2ip(nn uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, nn)
	return ip
}

// LiveAtlasServers will build a list of all the live servers in the grid for
// the realm specified
func LiveAtlasServers(realm string) {
	b := InitOfficialBaseIPs(realm)
	//log.Println(b)
	var l AtlasServers
	var r Realm
	r.RealmName = realm
	gridSize := 15
	portsPerServer := 4
	portCount := 1

	for i := 0; i < (gridSize * gridSize); i++ {
		var g Grids
		ipcount := (i / portsPerServer)
		portNum := 57554 + portCount
		grid := toGrid(i, gridSize)
		//log.Printf("count: %v is %v and ip: %v port: %v", i, grid, ipcount, portNum)
		g.Grid = grid
		g.Config.AtlasIP = incIP(b, ipcount)
		g.Config.AtlasQueryPort = strconv.Itoa(portNum)
		portCount++
		portCount++
		if portCount == 9 {
			portCount = 1
		}
		// Need to calculate what the ip should be based off a base IP, 4
		// servers per IP.  lets try and use ipcount to count from what the base
		// server for this realm is.  likely to break if they change subnets,
		// but unfuck that when we get to it Also not going to convert it to a
		// net.ip or anything just yet.  This means we could easily break things
		// by say incrementing beyond a subnet boundary, but lets get it working
		// right first.

		r.AddGrid(g)
	}
	l.AddOfficialRealm(r)
	//PrettyPrint(l)

	for _, v := range l.Official {
		if v.RealmName == realm {
			//PrettyPrint(v)
			for _, g := range v.Grids {
				log.Printf("%v | %v:%v", g.Grid, g.Config.AtlasIP, g.Config.AtlasQueryPort)
			}
		}
	}
}

func main() {
	log.SetFlags(log.LstdFlags | log.Lmicroseconds | log.Lshortfile)
	// cfg := Config{}
	// err := env.Parse(&cfg)

	// if CheckNoError(err) == false {
	// 	os.Exit(1)
	// }

	//statusPtr := flag.Bool("status", false, "Check the status of the server")
	//serverPtr := flag.String("s", "", "IP Address of the server to connect to")
	//portPtr := flag.String("p", "", "Port on the server to connect to")
	//pingPtr := flag.Bool("ping", false, "Simply checks if server responds to query on that port")
	//gridPtr := flag.Bool("grid", false, "used to print out possible grid assignments based on 4 ports per IP, consecutive IP's")
	livePtr := flag.String("live", "", "to run status/ping on live servers")
	flag.Parse()

	if len(*livePtr) > 0 {
		// Build out a grid of all the live servers
		realm := *livePtr
		LiveAtlasServers(realm)
		os.Exit(0)
	}

	// if *gridPtr == true {
	// 	makeGrid(15, 4)
	// 	os.Exit(0)
	// }

	// if len(*serverPtr) > 0 {
	// 	cfg.AtlasIP = strings.TrimSpace(*serverPtr)
	// 	//log.Print(Cfg.AtlasIP)
	// }
	// if len(*portPtr) > 0 {
	// 	cfg.AtlasQueryPort = strings.TrimSpace(*portPtr)
	// 	//log.Print(Cfg.AtlasQueryPort)
	// }

	// if *pingPtr == true {
	// 	ServerPing(cfg)
	// }

	// if *statusPtr == true {
	// 	// fmt.Printf("Server IP: %v\n", Cfg.AtlasIP)
	// 	// fmt.Printf("Query Port: %v\n", Cfg.AtlasQueryPort)
	// 	CheckStatus(cfg)
	// }
	// argsWithProg := os.Args
	// if len(argsWithProg) < 3 {
	// 	fmt.Printf("Usage: %s <server> <port> or set ATLASIP and ATLASQUERYPORT Environment Variables\n", filepath.Base(argsWithProg[0]))
	// 	os.Exit(1)
	// }

	// server := argsWithProg[1]
	// port := argsWithProg[2]
	// if len(argsWithProg) > 3 {
	// 	debug = true
	// }
	// if len(argsWithProg) > 4 {
	// 	colorize = true
	// }

}
